# Truthify
CS50 Final Project - Spring 2024
Made by Ezra Sharpe, Armando Patino, & Daniel Ramirez

For our CS50 Final Project, our group developed a Chrome extension to alert Chrome browser users of potential misinformation present on the sites they visit. To make this project possible we utilized languages and material extracted from the CS50 curriculum but also methods that we had to research and implement on our own.

To begin, the nature of an extension was new to our whole group so some research was needed. We found that Chrome has pages and documentation dedicated to the design and development of Chrome extensions. As a result, we chose to create and house our extension in Chrome.

Upon reading the Chrome documentation of extension design and creation, we realized our Chrome extension would require a "manifest.json" file which we created and tailored to fit our project's needs and capabilities. The "manifest.json" file uses a JSON text format that is often used when data is sent from a server to a web page. Concerning the Chrome extension, the JSON file contains essential properties of the extension such as its version, name, description, permissions, browser behavior adjustments, among other things. In our case, through the "manifest.json" we were able to name the extension "Truthify"; list permissions that Truthify needs such as access to the URL's of the user's Chrome tabs and permission to create and display notifications using the "chrome.notifications" API; specify the background service worker for the extension as the file "background.js"; define how the extension will appear in the toolbar of the browser using the "Truthify.html"; and specify the icon for the extension which is the "Truthify.png" we designed. In all, the "manifest.json" serves as a configuration file that specifies how the extensions should behave and how it interacts with the browser and web pages the user visits.

As mentioned before, we included a background service worker for the extension as the file "background.js." "background.js" is responsible for monitoring changes in the URL of the active tab, checking the safety of the new URL by making a request to a local server, and displaying a notification based on the response. The "chrome.tabs.onUpdated.addListener" function listens for any updates to the tabs in the browser. If the URL of a tab changes (if(changeInfo.url)), it logs the new URL and calls the "checkUrlWithDatabase" function with the new URL. The "checkUrlWithDatabase" function sends a POST request to a local server at http://127.0.0.1:5000/api/check-url with the URL as the payload. It expects a JSON response from the server. If the server responds with a status of "ok," the function parses the JSON response and passes it to the "showNotification" function. The "showNotification" function creates a notification based on the response data from the server. It checks if the "status" property of the response data is 'safe'. If it is, it creates a notification saying the URL is safe. If it is not, it creates a notification saying the URL is not safe. The notification includes the URL (the first 19 characters of it), an icon, and a title, making a short, ultra-comprehensible message for the user.

In addition, we created the "Truthify.html" that serves as the popup for our Chrome extension. When you click on the extension's icon in the toolbar, this HTML page is displayed. A key feature of our HTML design includes an element (<meta name="viewport" content="width=device-width, initial-scale=1.0">) which creates a responsive web design by setting the width of the page to follow the screen-width of the device. At the same time, using the Bootstrap CSS library, we integrated a table design to comprehensively display the columns data from the corresponding domain data when informing the user of the unsafe site they are visiting.

But for "truthify.html" to display the correct information, the "html.js" is needed to update the extension's popup page with said information. "html.js" does this by querying the currently active tab, sending the tab's URL to a local server to check its safety, and updateing the extension's popup page based on the response. The "chrome.tabs.query{active: true, currentWindow: true}, function(tabs) {...}" function queries the currently active tab in the current window. The callback function is invoked with an array of "Tab" objects representing the active tab. The "const url = tabs[0].url" line gets the URL of the currently active tab. The "fetch" function sends a POST request to a local server at http://127.0.0.1:5000/api/check-url with the URL as the payload. It expects a JSON reponse form the server. If the server responds successfully, the function parses the JSON response and updates the content of the HTML elements in the extension's popup page. If the "status" property of the response data is 'unsafe', it updates the text content of several HTML elements (url, label, source, lastUpdate, harmScore, type), sets the text content of the "statusMessage" element to 'Website is unsafe', shows the "infoTable" and "heading" elements, and changes the background color of the body to light gray. However, if the "status" property of the response data is not 'unsafe', it sets the text content of the "statusMessage" element to 'âœ…', hides the "infoTable" and "heading" elements, and changes the background color of the body to green.

We also implemented a "script.py" file that reads the data from the domain CSV file and writes it to a SQLite database. In "script.py," the necessary libraries are imported: "pandas" and "sqlite3." Then the data is read from the domains CSV file specified in "csv_file" using "pandas.read_csv()" and is stored in a DataFrame "df." The new SQLite database is created which has a connection to a database file nameed "truthify.db." Finally, the data from the DataFrame "df" is written to a new SQLite table named "data" in the "truthify.db" database. If a table with the same name already exists, it will be replaced (if_exists='replace'). The "index=False" argument means that index values will not be saved in the database. In summary, the script reads data from the domain CSV file and writes it to a SQLite database.

Another main part of the project is housed in the "app.py" file. This Python script creates a Flask web application that provides an API endpoint for checking if a given URL is considered "unsafe" based on data stored in a SQLite database. It first imports the necessary modules, such as 'Flask', 'request', and 'jsonify' from the 'flask' module for creating the web application and handling requests, 'cross_origin' and 'CORS' from 'flask_cors' for handling Cross-Origin Resource Sharing (CORS), and 'sqlite3' for interacting with a SQLite database. The Python file then creates a new Flask web application and sets up CORS for the application. Then, it defines a function "extract_domain(url)" that extracts the domain part of a URL using a regular expression. It also defines a route "/api/check-url" that listens for POST requests. This route is decorated with "@cross_origin()" to enable CORS for this route. In the "check_url()" function, the code gets the JSON data from the request, extracts the "url" value, and prints it. In addition, it extracts the domain part of the URL and uses it to query the database for a record where the "url" field matches the domain. If a match is found, it fetches the first record; otherwise, it sets "result" to "None." If a matching record was found in the database, it returns a JSON response with the status set to "unsafe" and the details of the record. If no match was found, it returns a JSON response with the status set to "safe." In all, the "app.py" script creates a Flask web application that provides an API endpoint to check if a given URL is considered "unsafe" based on data stored in the SQLite database, by extracting the domain from the URL, querying the database, and returning a JSON response with the status and details of the record if found.